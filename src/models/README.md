# Data Models

## Overview

The Data Models module defines core data structures used throughout the Algorithmic Trading System. These models provide standardized representations for trading signals, market data, and other key components, ensuring consistent data handling across the system.

## Key Components

The module contains the following key components:

### Signal Models

- **SignalType**: Enum class defining different types of trading signals (BUY, SELL, etc.)
- **SignalStrength**: Enum class defining levels of signal confidence (STRONG, MODERATE, etc.)
- **Signal**: Dataclass representing a trading signal generated by a strategy

## Data Structures

### SignalType

An enumeration that defines the possible types of trading signals:

```python
class SignalType(Enum):
    BUY = "BUY"            # Signal to enter a long position
    SELL = "SELL"          # Signal to enter a short position
    EXIT_LONG = "EXIT_LONG"  # Signal to exit a long position
    EXIT_SHORT = "EXIT_SHORT"  # Signal to exit a short position
    NONE = "NONE"          # No signal / neutral
```

### SignalStrength

An enumeration that defines the confidence levels of signals:

```python
class SignalStrength(Enum):
    VERY_STRONG = "VERY_STRONG"  # Highest confidence level
    STRONG = "STRONG"            # Strong confidence
    MODERATE = "MODERATE"        # Moderate confidence
    WEAK = "WEAK"                # Weak confidence
    NEUTRAL = "NEUTRAL"          # Neutral signal
    UNKNOWN = "UNKNOWN"          # Confidence level not determined
```

### Signal

A dataclass representing a trading signal generated by a strategy:

```python
@dataclass
class Signal:
    symbol: str             # Trading symbol (e.g., "BTCUSDT")
    signal_type: SignalType  # Type of signal (BUY, SELL, etc.)
    timestamp: datetime     # When the signal was generated
    price: float            # Price at which the signal was generated
    strategy_name: str      # Name of the strategy generating the signal
    timeframe: str          # Timeframe of the data used (e.g., "1h")
    confidence: float = 0.0  # Confidence score (0.0 to 1.0)
    volume: Optional[float] = None  # Trading volume
    strength: SignalStrength = SignalStrength.UNKNOWN  # Signal strength
    metadata: Dict[str, Any] = None  # Additional metadata
```

The `Signal` class includes helpful methods:

- `__post_init__()`: Ensures proper initialization of the signal
- `to_dict()`: Converts the signal to a dictionary for serialization
- `from_dict()`: Creates a Signal instance from a dictionary (deserialization)

## Usage Examples

### Creating a Signal

```python
from src.models.models import Signal, SignalType, SignalStrength
from datetime import datetime

# Create a buy signal
buy_signal = Signal(
    symbol="BTCUSDT",
    signal_type=SignalType.BUY,
    timestamp=datetime.now(),
    price=50000.0,
    strategy_name="ema_crossover",
    timeframe="1h",
    confidence=0.85,
    strength=SignalStrength.STRONG,
    metadata={"ema_fast": 9, "ema_slow": 21}
)

# Convert to dictionary for storage or transmission
signal_dict = buy_signal.to_dict()

# Recreate signal from dictionary
reconstructed_signal = Signal.from_dict(signal_dict)
```

### Using Signal Types

```python
from src.models.models import SignalType

# Check if a signal is a buy signal
if signal.signal_type == SignalType.BUY:
    # Process buy signal
    pass
elif signal.signal_type == SignalType.SELL:
    # Process sell signal
    pass
```

## Integration with Other Components

### Strategy Integration

Strategies generate `Signal` objects that are passed to the trading system:

```python
def generate_signals(self, data):
    signals = []

    # Generate signal based on strategy logic
    if buy_condition_met:
        signals.append(Signal(
            symbol=data.symbol,
            signal_type=SignalType.BUY,
            timestamp=data.index[-1],
            price=data['close'].iloc[-1],
            strategy_name=self.name,
            timeframe=self.timeframe,
            confidence=0.8,
            strength=SignalStrength.STRONG
        ))

    return signals
```

### Trade Management Integration

The Trade Management system processes signals to create orders:

```python
def process_signal(self, signal):
    if signal.signal_type == SignalType.BUY:
        # Create buy order
        self.create_order(
            symbol=signal.symbol,
            order_type="MARKET",
            side="BUY",
            quantity=self.calculate_position_size(signal)
        )
```

## Best Practices

1. **Serialization**: Always use the `to_dict()` and `from_dict()` methods when saving or transmitting signals
2. **Validation**: Validate signal properties before creating a Signal instance
3. **Metadata**: Use the metadata field to include strategy-specific information
4. **Confidence**: Use the confidence field to indicate the probability of signal success

## Development and Extension

To extend the data models:

1. Add new fields to existing classes as needed
2. Add new enum values to SignalType or SignalStrength if required
3. Ensure backward compatibility by handling missing fields in `from_dict()`
4. Update the serialization methods when adding new fields

## Error Handling

When working with Signal objects:

1. Handle potential missing fields in dictionaries
2. Validate timestamps and convert between string and datetime formats
3. Check for enum value validity when using string representations
